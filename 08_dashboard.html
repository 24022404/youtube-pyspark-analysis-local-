<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Real-time Analytics Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #fff;
        }
        .header {
            background: #181818;
            padding: 20px 32px;
            border-bottom: 1px solid #303030;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .header h1 {
            font-size: 24px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .status-group {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        .status {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid;
        }
        .status.live {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border-color: #4caf50;
        }
        .status.live::before {
            content: '●';
            animation: pulse 2s infinite;
        }
        .status.stale {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border-color: #ffc107;
        }
        .status.stale::before {
            content: '⏸';
        }
        .status.mock {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
            border-color: #ff9800;
        }
        .status.mock::before {
            content: '⚠';
        }
        .data-source {
            background: #212121;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .data-source .count {
            color: #fff;
            font-weight: 600;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .container {
            padding: 32px;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        /* Alert Banner */
        .alert-banner {
            background: linear-gradient(135deg, #ff9800, #ff5722);
            color: white;
            padding: 16px 24px;
            margin-bottom: 24px;
            border-radius: 12px;
            display: none;
            align-items: center;
            gap: 16px;
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
        }
        .alert-banner.show {
            display: flex;
        }
        .alert-banner.stale {
            background: linear-gradient(135deg, #ffc107, #ff9800);
        }
        .alert-icon {
            font-size: 32px;
        }
        .alert-content h3 {
            font-size: 16px;
            margin-bottom: 4px;
        }
        .alert-content p {
            font-size: 13px;
            opacity: 0.9;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 20px;
            margin-bottom: 32px;
        }
        .stat-card {
            background: #181818;
            border: 1px solid #303030;
            border-radius: 12px;
            padding: 24px;
            position: relative;
        }
        .stat-card.real-data::after {
            content: '✓ Real';
            position: absolute;
            top: 12px;
            right: 12px;
            font-size: 10px;
            padding: 4px 8px;
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border-radius: 4px;
            font-weight: 600;
        }
        .stat-card.stale-data::after {
            content: 'OLD';
            position: absolute;
            top: 12px;
            right: 12px;
            font-size: 10px;
            padding: 4px 8px;
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border-radius: 4px;
            font-weight: 600;
        }
        .stat-card.mock-data::after {
            content: 'MOCK';
            position: absolute;
            top: 12px;
            right: 12px;
            font-size: 10px;
            padding: 4px 8px;
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
            border-radius: 4px;
            font-weight: 600;
        }
        .stat-label {
            font-size: 13px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        .stat-value {
            font-size: 36px;
            font-weight: 600;
            line-height: 1;
            margin-bottom: 8px;
        }
        .stat-change {
            font-size: 14px;
            color: #4caf50;
        }
        .chart-section {
            background: #181818;
            border: 1px solid #303030;
            border-radius: 12px;
            padding: 28px;
            margin-bottom: 24px;
            position: relative;
        }
        .chart-section.real-data::before {
            content: '✓ Real-time Data';
            position: absolute;
            top: 20px;
            right: 28px;
            font-size: 11px;
            padding: 6px 12px;
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border-radius: 6px;
            font-weight: 600;
            border: 1px solid #4caf50;
        }
        .chart-section.stale-data::before {
            content: '⏸ Stale Data (No new updates)';
            position: absolute;
            top: 20px;
            right: 28px;
            font-size: 11px;
            padding: 6px 12px;
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border-radius: 6px;
            font-weight: 600;
            border: 1px solid #ffc107;
        }
        .chart-section.mock-data::before {
            content: '⚠ Mock Data (MongoDB not connected)';
            position: absolute;
            top: 20px;
            right: 28px;
            font-size: 11px;
            padding: 6px 12px;
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
            border-radius: 6px;
            font-weight: 600;
            border: 1px solid #ff9800;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }
        .chart-title {
            font-size: 18px;
            font-weight: 600;
        }
        .chart-subtitle {
            font-size: 13px;
            color: #aaa;
            margin-top: 4px;
        }
        canvas {
            max-height: 350px;
        }
        .predictions-table {
            background: #181818;
            border: 1px solid #303030;
            border-radius: 12px;
            padding: 28px;
            margin-bottom: 24px;
            position: relative;
        }
        .predictions-table.real-data::before {
            content: '✓ ML Predictions from Real Data';
            position: absolute;
            top: 20px;
            right: 28px;
            font-size: 11px;
            padding: 6px 12px;
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border-radius: 6px;
            font-weight: 600;
            border: 1px solid #4caf50;
        }
        .predictions-table.stale-data::before {
            content: '⏸ Stale Predictions';
            position: absolute;
            top: 20px;
            right: 28px;
            font-size: 11px;
            padding: 6px 12px;
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border-radius: 6px;
            font-weight: 600;
            border: 1px solid #ffc107;
        }
        .predictions-table.mock-data::before {
            content: '⚠ Mock Predictions';
            position: absolute;
            top: 20px;
            right: 28px;
            font-size: 11px;
            padding: 6px 12px;
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
            border-radius: 6px;
            font-weight: 600;
            border: 1px solid #ff9800;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        thead th {
            text-align: left;
            padding: 12px;
            font-size: 13px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #303030;
        }
        tbody td {
            padding: 16px 12px;
            border-bottom: 1px solid #202020;
        }
        tbody tr:hover {
            background: #202020;
        }
        .video-title {
            font-size: 14px;
            font-weight: 500;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .video-title.mock {
            color: #ff9800;
        }
        .growth-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
        }
        .growth-badge.positive {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #181818;
        }
        ::-webkit-scrollbar-thumb {
            background: #303030;
            border-radius: 4px;
        }
        
        /* Console Log Display */
        .debug-console {
            background: #000;
            border: 1px solid #303030;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        .debug-console .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #222;
        }
        .debug-console .log-entry.success {
            color: #4caf50;
        }
        .debug-console .log-entry.warning {
            color: #ff9800;
        }
        .debug-console .log-entry.error {
            color: #f44336;
        }
        .debug-console .log-entry.info {
            color: #2196f3;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            <span style="color: #ff0000;">▶</span>
            YouTube Real-time Analytics
        </h1>
        <div class="status-group">
            <div class="data-source">
                <span>Source:</span>
                <span class="count" id="dataSource">Checking...</span>
            </div>
            <div class="status live" id="status">
                Connecting...
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Alert Banner -->
        <div class="alert-banner" id="mockAlert">
            <div class="alert-icon">⚠️</div>
            <div class="alert-content">
                <h3>Using Mock Data</h3>
                <p>MongoDB is not connected. Start MongoDB and restart 07_realtime_analysis.py to see real data.</p>
            </div>
        </div>

        <div class="alert-banner stale" id="staleAlert">
            <div class="alert-icon">⏸️</div>
            <div class="alert-content">
                <h3>Data is Stale</h3>
                <p id="staleMessage">Last update was X minutes ago. Start 07_realtime_analysis.py to get fresh data.</p>
            </div>
        </div>

        <!-- Debug Console -->
        <div class="debug-console" id="debugConsole">
            <div class="log-entry info">[INFO] Dashboard initialized. Waiting for data...</div>
        </div>

        <!-- Real-time Stats -->
        <div class="stats-grid">
            <div class="stat-card" id="statCard1">
                <div class="stat-label">Total Videos</div>
                <div class="stat-value" id="totalVideos">0</div>
                <div class="stat-change">Last batch</div>
            </div>
            <div class="stat-card" id="statCard2">
                <div class="stat-label">Total Views</div>
                <div class="stat-value" id="totalViews">0</div>
                <div class="stat-change" id="viewsChange">--</div>
            </div>
            <div class="stat-card" id="statCard3">
                <div class="stat-label">Avg Engagement</div>
                <div class="stat-value" id="avgEngagement">0%</div>
                <div class="stat-change" id="engagementChange">--</div>
            </div>
            <div class="stat-card" id="statCard4">
                <div class="stat-label">Peak Upload Hour</div>
                <div class="stat-value" id="peakHour">--</div>
                <div class="stat-change">Most active</div>
            </div>
        </div>

        <!-- Category Distribution -->
        <div class="chart-section" id="categorySection">
            <div class="chart-header">
                <div>
                    <div class="chart-title">Category Distribution</div>
                    <div class="chart-subtitle">Real-time video count by category</div>
                </div>
            </div>
            <canvas id="categoryChart"></canvas>
        </div>

        <!-- Time Patterns -->
        <div class="chart-section" id="timeSection">
            <div class="chart-header">
                <div>
                    <div class="chart-title">Upload Time Distribution</div>
                    <div class="chart-subtitle">Videos uploaded by hour of day</div>
                </div>
            </div>
            <canvas id="timeChart"></canvas>
        </div>

        <!-- Engagement Analysis -->
        <div class="chart-section" id="engagementSection">
            <div class="chart-header">
                <div>
                    <div class="chart-title">Engagement Metrics by Category</div>
                    <div class="chart-subtitle">Average likes and comments per category</div>
                </div>
            </div>
            <canvas id="engagementChart"></canvas>
        </div>

        <!-- Predictions -->
        <div class="predictions-table" id="predictionsSection">
            <div class="chart-header">
                <div>
                    <div class="chart-title">Predicted Performance Tomorrow</div>
                    <div class="chart-subtitle">ML predictions based on current trends</div>
                </div>
            </div>
            <table>
                <thead>
                    <tr>
                        <th>Video Title</th>
                        <th>Category</th>
                        <th>Current Views</th>
                        <th>Predicted Views</th>
                        <th>Growth</th>
                    </tr>
                </thead>
                <tbody id="predictionsBody">
                    <tr>
                        <td colspan="5" style="text-align: center; color: #aaa; padding: 40px;">
                            Waiting for real-time data...
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const CATEGORY_MAP = {
            '1': 'Film & Animation', '2': 'Autos & Vehicles', '10': 'Music',
            '15': 'Pets & Animals', '17': 'Sports', '19': 'Travel & Events',
            '20': 'Gaming', '22': 'People & Blogs', '23': 'Comedy',
            '24': 'Entertainment', '25': 'News & Politics', '26': 'Howto & Style',
            '27': 'Education', '28': 'Science & Technology'
        };

        let categoryChart, timeChart, engagementChart;
        let allData = [];
        let isUsingMockData = false;
        let isStaleData = false;
        let updateCount = 0;
        const STALE_THRESHOLD = 60; // 60 seconds = 1 minute

        // Debug console
        function addLog(message, type = 'info') {
            const console = document.getElementById('debugConsole');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            console.appendChild(entry);
            console.scrollTop = console.scrollHeight;
            
            // Keep only last 20 logs
            if (console.children.length > 20) {
                console.removeChild(console.firstChild);
            }
        }

        // Update status indicator
        function updateStatusIndicator(text, type, isMock, isStale = false) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = text;
            statusEl.className = 'status ' + type;
            
            const sourceEl = document.getElementById('dataSource');
            if (isMock) {
                sourceEl.textContent = 'Mock Data';
            } else if (isStale) {
                sourceEl.textContent = 'MongoDB (Stale)';
            } else {
                sourceEl.textContent = 'MongoDB (Real-time)';
            }
            
            // Update alert banners
            const mockAlert = document.getElementById('mockAlert');
            const staleAlert = document.getElementById('staleAlert');
            
            if (isMock) {
                mockAlert.classList.add('show');
                staleAlert.classList.remove('show');
            } else if (isStale) {
                mockAlert.classList.remove('show');
                staleAlert.classList.add('show');
            } else {
                mockAlert.classList.remove('show');
                staleAlert.classList.remove('show');
            }
            
            // Update all sections
            const sections = ['statCard1', 'statCard2', 'statCard3', 'statCard4', 
                            'categorySection', 'timeSection', 'engagementSection', 'predictionsSection'];
            sections.forEach(id => {
                const el = document.getElementById(id);
                el.classList.remove('real-data', 'mock-data', 'stale-data');
                if (isMock) {
                    el.classList.add('mock-data');
                } else if (isStale) {
                    el.classList.add('stale-data');
                } else {
                    el.classList.add('real-data');
                }
            });
        }

        // Check if data is stale
        function checkDataFreshness(data) {
            if (!data || data.length === 0) return { isStale: true, ageSeconds: 0 };
            
            // Tìm timestamp mới nhất
            let latestTimestamp = null;
            for (let item of data) {
                const ts = item.processing_timestamp || item.timestamp || item.kafka_timestamp;  // ← ĐÚNG
                if (ts) {
                    const date = new Date(ts);
                    if (!latestTimestamp || date > latestTimestamp) {
                        latestTimestamp = date;
                    }
                }
            }
            
            if (!latestTimestamp) return { isStale: true, ageSeconds: 0 };
            
            const now = new Date();
            const ageSeconds = (now - latestTimestamp) / 1000;
            
            return {
                isStale: ageSeconds > STALE_THRESHOLD,
                ageSeconds: ageSeconds,
                latestTimestamp: latestTimestamp
            };
        }

        // Fetch real-time data
        async function fetchRealtimeData() {
            updateCount++;
            addLog(`Attempt ${updateCount}: Fetching data from Flask API...`, 'info');
            
            try {
                const response = await fetch('http://localhost:5000/api/realtime', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data && data.length > 0) {
                    // KIỂM TRA ĐỘ TƯI CỦA DATA
                    const freshness = checkDataFreshness(data);
                    
                    isUsingMockData = false;
                    isStaleData = freshness.isStale;
                    
                    if (freshness.isStale) {
                        const minutes = Math.floor(freshness.ageSeconds / 60);
                        const seconds = Math.floor(freshness.ageSeconds % 60);
                        
                        updateStatusIndicator(
                            `STALE DATA (${minutes}m ${seconds}s old)`, 
                            'stale', 
                            false, 
                            true
                        );
                        
                        document.getElementById('staleMessage').textContent = 
                            `Last update was ${minutes} minute(s) ${seconds} second(s) ago. Start 07_realtime_analysis.py to get fresh data.`;
                        
                        addLog(`⚠ WARNING: Data is ${minutes}m ${seconds}s old (STALE)`, 'warning');
                        addLog(`Latest timestamp: ${freshness.latestTimestamp.toLocaleString()}`, 'info');
                    } else {
                        updateStatusIndicator('LIVE - Real Data', 'live', false, false);
                        addLog(`✓ SUCCESS: Loaded ${data.length} videos (FRESH DATA)`, 'success');
                    }
                    
                    return data;
                } else {
                    throw new Error('MongoDB returned empty data');
                }
                
            } catch (error) {
                isUsingMockData = true;
                isStaleData = false;
                updateStatusIndicator('MOCK DATA', 'mock', true, false);
                addLog(`✗ ERROR: ${error.message}`, 'error');
                addLog('⚠ Falling back to mock data...', 'warning');
                return generateMockData();
            }
        }

        // Mock data generator
        function generateMockData() {
            const categories = ['10', '20', '24', '27', '28'];
            const data = [];
            for (let i = 0; i < 50; i++) {
                const categoryId = categories[Math.floor(Math.random() * categories.length)];
                data.push({
                    video_id: 'MOCK_' + i,
                    title: `[MOCK DATA] Video ${i + 1}: ${CATEGORY_MAP[categoryId]}`,
                    categoryId: categoryId,
                    view_count: Math.floor(Math.random() * 1000000) + 10000,
                    likes: Math.floor(Math.random() * 50000) + 100,
                    comment_count: Math.floor(Math.random() * 5000) + 50,
                    publishedAt: new Date(Date.now() - Math.random() * 86400000 * 7).toISOString(),
                    predicted_views_tomorrow: 0
                });
            }
            data.forEach(v => {
                v.predicted_views_tomorrow = v.view_count * (1 + Math.random() * 0.3);
            });
            return data;
        }

        // Update stats
        function updateStats(data) {
            const totalVideos = data.length;
            const totalViews = data.reduce((sum, v) => sum + v.view_count, 0);
            const avgEngagement = data.reduce((sum, v) => {
                return sum + ((v.likes + v.comment_count) / v.view_count * 100);
            }, 0) / totalVideos;

            const hourCounts = {};
            data.forEach(v => {
                const hour = new Date(v.publishedAt).getHours();
                hourCounts[hour] = (hourCounts[hour] || 0) + 1;
            });
            const peakHour = Object.keys(hourCounts).reduce((a, b) => 
                hourCounts[a] > hourCounts[b] ? a : b
            );

            document.getElementById('totalVideos').textContent = totalVideos.toLocaleString();
            document.getElementById('totalViews').textContent = (totalViews / 1e6).toFixed(1) + 'M';
            document.getElementById('avgEngagement').textContent = avgEngagement.toFixed(2) + '%';
            document.getElementById('peakHour').textContent = peakHour + ':00';
            
            if (isUsingMockData) {
                document.getElementById('viewsChange').textContent = '(Mock)';
            } else if (isStaleData) {
                document.getElementById('viewsChange').textContent = '(Stale)';
            } else {
                document.getElementById('viewsChange').textContent = '(Real-time)';
            }
        }

        // Category chart
        function updateCategoryChart(data) {
            const categoryCounts = {};
            data.forEach(v => {
                const cat = CATEGORY_MAP[v.categoryId] || 'Unknown';
                categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            });

            const sortedCategories = Object.entries(categoryCounts)
                .sort((a, b) => b[1] - a[1]);

            if (categoryChart) categoryChart.destroy();

            const ctx = document.getElementById('categoryChart').getContext('2d');
            categoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedCategories.map(x => x[0]),
                    datasets: [{
                        data: sortedCategories.map(x => x[1]),
                        backgroundColor: isUsingMockData ? '#ff9800' : (isStaleData ? '#ffc107' : '#ff0000'),
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { 
                            grid: { color: '#303030' },
                            ticks: { color: '#aaa', font: { size: 11 } }
                        },
                        y: { 
                            grid: { color: '#303030' },
                            ticks: { color: '#aaa' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Time chart
        function updateTimeChart(data) {
            const hourCounts = Array(24).fill(0);
            data.forEach(v => {
                const hour = new Date(v.publishedAt).getHours();
                hourCounts[hour]++;
            });

            if (timeChart) timeChart.destroy();

            const ctx = document.getElementById('timeChart').getContext('2d');
            timeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 24}, (_, i) => i + ':00'),
                    datasets: [{
                        label: 'Videos',
                        data: hourCounts,
                        backgroundColor: isUsingMockData ? 'rgba(255, 152, 0, 0.2)' : (isStaleData ? 'rgba(255, 193, 7, 0.2)' : 'rgba(59, 130, 246, 0.2)'),
                        borderColor: isUsingMockData ? '#ff9800' : (isStaleData ? '#ffc107' : '#3b82f6'),
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { 
                            grid: { color: '#303030' },
                            ticks: { color: '#aaa', font: { size: 11 } }
                        },
                        y: { 
                            grid: { color: '#303030' },
                            ticks: { color: '#aaa' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Engagement chart
        function updateEngagementChart(data) {
            const categoryStats = {};
            data.forEach(v => {
                const cat = CATEGORY_MAP[v.categoryId] || 'Unknown';
                if (!categoryStats[cat]) {
                    categoryStats[cat] = { likes: [], comments: [] };
                }
                categoryStats[cat].likes.push(v.likes);
                categoryStats[cat].comments.push(v.comment_count);
            });

            const categories = Object.keys(categoryStats);
            const avgLikes = categories.map(cat => {
                const arr = categoryStats[cat].likes;
                return arr.reduce((a, b) => a + b, 0) / arr.length;
            });
            const avgComments = categories.map(cat => {
                const arr = categoryStats[cat].comments;
                return arr.reduce((a, b) => a + b, 0) / arr.length;
            });

            if (engagementChart) engagementChart.destroy();

            const ctx = document.getElementById('engagementChart').getContext('2d');
            engagementChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: categories,
                    datasets: [{
                        label: 'Avg Likes',
                        data: avgLikes,
                        backgroundColor: isUsingMockData ? '#ff9800' : (isStaleData ? '#ffc107' : '#4caf50'),
                        borderRadius: 4
                    }, {
                        label: 'Avg Comments',
                        data: avgComments,
                        backgroundColor: isUsingMockData ? '#ff5722' : (isStaleData ? '#ff9800' : '#ffa500'),
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#aaa', font: { size: 12 } }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { color: '#303030' },
                            ticks: { color: '#aaa', font: { size: 11 } }
                        },
                        y: { 
                            grid: { color: '#303030' },
                            ticks: { color: '#aaa' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Predictions table
        async function fetchPredictionsFromAPI() {
            try {
                const response = await fetch('http://localhost:5000/api/predictions');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const predictions = await response.json();
                
                const tbody = document.getElementById('predictionsBody');
                
                if (!predictions || predictions.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #aaa; padding: 40px;">No predictions available yet</td></tr>';
                    addLog('No predictions data available', 'warning');
                    return;
                }
                
                // CHECK FRESHNESS OF PREDICTIONS
                const freshness = checkDataFreshness(predictions);
                if (freshness.isStale) {
                    const minutes = Math.floor(freshness.ageSeconds / 60);
                    addLog(`⚠ Predictions are ${minutes}m old`, 'warning');
                }
                
                addLog(`✓ Loaded ${predictions.length} predictions`, 'success');
                
                tbody.innerHTML = predictions.slice(0, 10).map(p => {
                    const category = p.categoryId ? (CATEGORY_MAP[p.categoryId] || 'Unknown') : 'N/A';
                    const growth = ((p.predicted_views_tomorrow - p.view_count) / p.view_count * 100).toFixed(1);
                    const isMock = p.video_id && p.video_id.startsWith('MOCK_');
                    
                    return `
                        <tr>
                            <td><div class="video-title ${isMock ? 'mock' : ''}">${p.title || 'Unknown'}</div></td>
                            <td style="color: #aaa;">${category}</td>
                            <td>${(p.view_count || 0).toLocaleString()}</td>
                            <td>${Math.round(p.predicted_views_tomorrow || 0).toLocaleString()}</td>
                            <td><span class="growth-badge positive">+${growth}%</span></td>
                        </tr>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Prediction error:', error);
                addLog(`✗ Prediction error: ${error.message}`, 'error');
                
                const tbody = document.getElementById('predictionsBody');
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #f44336; padding: 20px;">Error loading predictions</td></tr>';
            }
        }

        // Main update
        async function updateDashboard() {
            addLog('Starting dashboard update...', 'info');
            const data = await fetchRealtimeData();
            allData = data;

            updateStats(data);
            updateCategoryChart(data);
            updateTimeChart(data);
            updateEngagementChart(data);
            
            await fetchPredictionsFromAPI();
            
            addLog(`Dashboard updated with ${data.length} videos`, 'success');
        }

        // Auto refresh
        updateDashboard();
        setInterval(updateDashboard, 5000);
    </script>
</body>
</html>